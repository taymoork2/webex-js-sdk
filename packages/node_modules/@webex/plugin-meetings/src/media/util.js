/* globals window, document, MediaStream, AudioContext */

/*
  Silence code influenced from:
    - https://stackoverflow.com/questions/46543341/how-can-i-extract-the-preceding-audio-from-microphone-as-a-buffer-when-silence
    - https://github.com/twilio/twilio-video.js/blob/master/lib/util/detectsilentvideo.js
    - https://github.com/twilio/twilio-video.js/blob/master/lib/util/detectsilentaudio.js
    - https://github.com/twilio/twilio-video.js/blob/master/lib/webaudio/detectsilence.js
*/

import bowser from 'bowser';

import {
  DETECT_AUDIO_SILENCE_ATTEMPTS,
  DETECT_AUDIO_SILENCE_ATTEMPT_DURATION_MS,
  DETECT_VIDEO_SILENCE_SAMPLES,
  DETECT_VIDEO_SILENCE_SAMPLE_INTERVAL_MS,
  RTC_CONFIGURATION,
  RTC_CONFIGURATION_FIREFOX
} from '../constants';
import LoggerProxy from '../common/logs/logger-proxy';

import checkAudioSilence from './detectSilence/audioSilence';
import checkVideoSilence from './detectSilence/videoSilence';

const createPeerConnection = () => new window.RTCPeerConnection(
  bowser.firefox ? RTC_CONFIGURATION_FIREFOX : RTC_CONFIGURATION
);

const createMediaStream = (tracks) => {
  if (!tracks) {
    LoggerProxy.logger.error('Media:util#createMediaStream --> Tracks don\'t exist');
  }
  const filtredTracks = tracks.filter((element) => !!element);

  return new MediaStream(filtredTracks);
};

/**
 * Detect whether the audio stream rendered by the given HTMLVideoElement is silent.
 * @param {HTMLMediaElement | HTMLAudioElement | MediaStream} audioStream
 * @returns {Promise<boolean>} true if silent, false if not.
 */
const detectAudioSilence = (audioStream) => {
  const audioContext = new AudioContext();
  let attemptsLeft = DETECT_AUDIO_SILENCE_ATTEMPTS;

  // eslint-disable-next-line require-jsdoc
  function doCheckSilence() {
    attemptsLeft -= 1;

    return checkAudioSilence(
      audioContext,
      audioStream.srcObject || audioStream,
      DETECT_AUDIO_SILENCE_ATTEMPT_DURATION_MS
    ).then((isSilent) => {
      if (!isSilent) {
        return false;
      }

      if (attemptsLeft > 0) {
        return doCheckSilence();
      }

      return true;
    }).catch(() => true);
  }

  // Resolve the returned Promise with true if 3 consecutive attempts
  // to detect silent audio are successful.
  return doCheckSilence().finally(() => {
    audioContext.close();
  });
};

/**
 * Detect whether the video stream rendered by the given HTMLVideoElement is silent.
 * @param {HTMLMediaElement | HTMLVideoElement | MediaStream} videoStream
 * @returns {Promise<boolean>} true if silent, false if not.
 */
const detectVideoSilence = (videoStream) => {
  const el = videoStream.srcObject ?
    videoStream :
    Object.assign(document.createElement('video'), {srcObject: videoStream});


  // Create the canvas when detectVideoSilence() is called for the
  // first time.
  const canvas = document.createElement('canvas');

  // Resolve the returned Promise with true if 3 consecutive sample
  // frames from the video being played by the HTMLVideoElement are
  // silent.
  return new Promise((resolve) => {
    let samplesLeft = DETECT_VIDEO_SILENCE_SAMPLES;

    const doCheckVideoSilence = () => {
      samplesLeft -= 1;

      if (!checkVideoSilence(el, canvas)) {
        return resolve(false);
      }
      if (samplesLeft > 0) {
        return setTimeout(doCheckVideoSilence, DETECT_VIDEO_SILENCE_SAMPLE_INTERVAL_MS);
      }

      return resolve(true);
    };

    setTimeout(doCheckVideoSilence, DETECT_VIDEO_SILENCE_SAMPLE_INTERVAL_MS);
  });
};

export default {
  createPeerConnection,
  createMediaStream,
  detectAudioSilence,
  detectVideoSilence
};
